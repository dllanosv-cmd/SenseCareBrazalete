T#include <MAX3010x.h>
#include <Adafruit_SSD1306.h>
#include "filters.h"
#include <Arduino.h>
#include <WiFi.h>
#include <Firebase_ESP_Client.h>
#include "time.h"
#include "apwifieeprommode.h"
#include <EEPROM.h>

// Para la fecha y hora. Zona horaria (Ecuador: UTC -5)
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = -5 * 3600;
const int daylightOffset_sec = 0;



// Firebase
#define API_KEY "AIzaSyBvLJjVUC9DcJ5xXWC5Evca6tWYkxIPwhs"
#define DATABASE_URL "https://maxesp32-e9124-default-rtdb.firebaseio.com"

FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET     -1

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
MAX30105 sensor;
//cálculos y mediciones
const auto kSamplingRate = sensor.SAMPLING_RATE_400SPS;
const float kSamplingFrequency = 400.0;

const unsigned long kFingerThreshold = 10000;
const unsigned int kFingerCooldownMs = 500;
const float kEdgeThreshold = -2000.0;

const float kLowPassCutoff = 5.0;
const float kHighPassCutoff = 0.5;
const bool kEnableAveraging = true;
const int kAveragingSamples = 5;
const int kSampleThreshold = 5;
 
LowPassFilter low_pass_filter_red(kLowPassCutoff, kSamplingFrequency);
LowPassFilter low_pass_filter_ir(kLowPassCutoff, kSamplingFrequency);
HighPassFilter high_pass_filter(kHighPassCutoff, kSamplingFrequency);
Differentiator differentiator(kSamplingFrequency);
MovingAverageFilter<kAveragingSamples> averager_bpm;
MovingAverageFilter<kAveragingSamples> averager_r;
MovingAverageFilter<kAveragingSamples> averager_spo2;
MinMaxAvgStatistic stat_red;
MinMaxAvgStatistic stat_ir;

float kSpO2_A = 1.5958422;
float kSpO2_B = -34.6596622;
float kSpO2_C = 112.6898759;

long last_heartbeat = 0;
long finger_timestamp = 0;
bool finger_detected = false;
float last_diff = NAN;
bool crossed = false;
long crossed_time = 0;
bool display_reset = true;
// Configuración de LEDs (ánodo común)
const int TEMP_LED_RED = 13;
const int TEMP_LED_GREEN = 27;
const int SPO2_LED_RED = 26;
const int SPO2_LED_GREEN = 12;
const int BPM_LED_RED = 14;
const int BPM_LED_GREEN = 25;

// Variables compartidas para el estado de los LEDs
volatile int ledBpmState = 0;      // 0=apagado, 1=verde, 2=rojo
volatile int ledSpo2State = 0;
volatile int ledTempState = 0;

// Task handles
TaskHandle_t ledTaskHandle = NULL;


void initDrawScreen(void);
void displayMeasuredValues(bool no_finger, int32_t beatAvg, int32_t spo2, float temperature);
String getCurrentTimeKey();
String getCurrentDate();
void actualizarIndicadores(int average_bpm, int average_spo2, float temperature);
void ledControlTask(void *pvParameters);

void setup() {
  Serial.begin(115200);
  //Para el Apwifi
  intentoconexion("brazalete", "12345678");
  
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    while (1);
  }
 
  if (sensor.begin() && sensor.setSamplingRate(kSamplingRate)) {
    Serial.println("Sensor initialized");
  } else {
    Serial.println("Sensor not found");
    while (1);
  }

  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;

  auth.user.email = "jaellanosvelez@gmail.com";
  auth.user.password = "qwerdda236#";

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  display.clearDisplay();
  initDrawScreen();

  // Configurar el servidor de tiempo
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

  // Configurar pines LED como salidas
  pinMode(BPM_LED_GREEN, OUTPUT);
  pinMode(BPM_LED_RED, OUTPUT);
  pinMode(SPO2_LED_GREEN, OUTPUT);
  pinMode(SPO2_LED_RED, OUTPUT);
  pinMode(TEMP_LED_GREEN, OUTPUT);
  pinMode(TEMP_LED_RED, OUTPUT);

  // Estado inicial: todos los LEDs en verde
  digitalWrite(BPM_LED_GREEN, LOW);   // encendido (ánodo común)
  digitalWrite(BPM_LED_RED, HIGH);    // apagado
  digitalWrite(SPO2_LED_GREEN, LOW);
  digitalWrite(SPO2_LED_RED, HIGH);
  digitalWrite(TEMP_LED_GREEN, LOW);
  digitalWrite(TEMP_LED_RED, HIGH);
   xTaskCreatePinnedToCore(
    ledControlTask,    // Función de la task
    "LEDControl",      // Nombre
    2000,              // Stack size
    NULL,              // Parámetros
    1,                 // Prioridad
    &ledTaskHandle,    // Task handle
    0                  // Core (0 o 1)
  );
}


void loop() {
  //Para el Apwifi
  loopAP();
  //lecturas del sensor
  auto sample = sensor.readSample(1000);
  float temperature = sensor.readTemperature();
  float current_value_red = sample.red;
  float current_value_ir = sample.ir;

  if (sample.red > kFingerThreshold) {
    if (millis() - finger_timestamp > kFingerCooldownMs) {
      finger_detected = true;
    }
  } else {
    differentiator.reset();
    averager_bpm.reset();
    averager_r.reset();
    averager_spo2.reset();
    low_pass_filter_red.reset();
    low_pass_filter_ir.reset();
    high_pass_filter.reset();
    stat_red.reset();
    stat_ir.reset();

    finger_detected = false;
    finger_timestamp = millis();
  }

  if (finger_detected) {
    displayMeasuredValues(false, 0, 0, temperature);
    current_value_red = low_pass_filter_red.process(current_value_red);
    current_value_ir = low_pass_filter_ir.process(current_value_ir);

    stat_red.process(current_value_red);
    stat_ir.process(current_value_ir);

    float current_value = high_pass_filter.process(current_value_red);
    float current_diff = differentiator.process(current_value);

    if (!isnan(current_diff) && !isnan(last_diff)) {
      if (last_diff > 0 && current_diff < 0) {
        crossed = true;
        crossed_time = millis();
      }

      if (current_diff > 0) {
        crossed = false;
      }

      if (crossed && current_diff < kEdgeThreshold) {
        if (last_heartbeat != 0 && crossed_time - last_heartbeat > 300) {
          int bpm = 60000 / (crossed_time - last_heartbeat);
          float rred = (stat_red.maximum() - stat_red.minimum()) / stat_red.average();
          float rir = (stat_ir.maximum() - stat_ir.minimum()) / stat_ir.average();
          float r = rred / rir;
          float spo2 = kSpO2_A * r * r + kSpO2_B * r + kSpO2_C;

          if (bpm > 50 && bpm < 250) {
            if (kEnableAveraging) {
              int average_bpm = averager_bpm.process(bpm);
              int average_r = averager_r.process(r);
              int average_spo2 = averager_spo2.process(spo2);
              //encendido de leds
              
              if (averager_bpm.count() >= kSampleThreshold) {
                //Serial.println("Time (ms): " + String(millis()));
                Serial.println("Heart Rate (avg, bpm): " + String(average_bpm));
                Serial.println("SpO2 (avg, %): " + String(average_spo2));
                Serial.println("Temp (°C): " + String(temperature, 1));
               
                //mostrar mediciones en la pantalla
                displayMeasuredValues(false, average_bpm, average_spo2, temperature);
                actualizarIndicadores(average_bpm, average_spo2, temperature);

                //Base de Datos
                String basePath = "/lecturas";
                // Obtener fecha y hora actual
                String dateKey = getCurrentDate();     // "2025-07-27"
                String timeKey = getCurrentTimeKey();  // "143225"

                // Crear ruta completa: /lecturas/2025-07-27/143225
                String path = basePath + "/" + dateKey + "/" + timeKey;

                // Guardar los datos en esa ruta
                if (Firebase.RTDB.setInt(&fbdo, path + "/bpm", average_bpm) &&
                    Firebase.RTDB.setInt(&fbdo, path + "/spo2", average_spo2) &&
                    Firebase.RTDB.setFloat(&fbdo, path + "/temperatura", temperature) &&
                    Firebase.RTDB.setInt(&fbdo, path + "/timestamp", millis())) {
                  Serial.println("Datos guardados exitosamente en: " + path);
                } else {
                  Serial.println("Error guardando datos: " + fbdo.errorReason());
                }
                         
              }
             
             
            } else {
              Serial.println("Heart Rate (bpm): " + String(bpm));
              Serial.println("SpO2 (%): " + String(spo2));
              Serial.println("Temp (°C): " + String(temperature, 1));
              displayMeasuredValues(false, bpm, spo2, temperature);
              
            }
          }

          stat_red.reset();
          stat_ir.reset();
        }

        crossed = false;
        last_heartbeat = crossed_time;
      }
    }

    last_diff = current_diff;
  } else {
    displayMeasuredValues(true, 0, 0, temperature);
  }
}

void initDrawScreen(void) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(0, 0);
  display.println(F("    Taste The Code"));
  display.setCursor(5, display.getCursorY() + 5);
  display.setTextSize(2);
  display.println(F("BPM  SpO2  Temp"));
  display.display();
}

void displayMeasuredValues(bool no_finger, int32_t beatAvg, int32_t spo2, float temperature) {
  display.clearDisplay();
  display.setTextColor(WHITE);

  if (no_finger) {
    display.setTextSize(2);
    display.setCursor(5, 10);
    display.println(F("NO Signal"));
    display.display();
    display_reset = true;
  } else if (beatAvg < 30 && display_reset) {
    display.setTextSize(2);
    display.setCursor(5, 10);
    display.println(F("Pls. Wait"));
    display.display();
    display_reset = false;
  } else if (beatAvg >= 30) {
    display.setTextSize(2);
    display.setCursor(0, 0);
    display.print(F("BPM: "));
    display.println(beatAvg);

    display.setCursor(0, 20);
    display.print(F("SpO2: "));
    if (spo2 >= 20 && spo2 <= 100) {
      display.print(spo2);
    } else {
      display.print(F("--"));
    }
    display.println(F("%"));

    display.setCursor(0, 40);
    display.print(F("Tmp: "));
    display.print(temperature, 1);
    display.println(F("C"));

    display.display();
  }
}
String getCurrentTimeKey() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Error obteniendo hora");
    return "000000";  // Fallback
  }

  char timeStr[10];
  sprintf(timeStr, "%02d%02d%02d", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
  return String(timeStr);
}
String getCurrentDate() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Error obteniendo fecha");
    return "1970-01-01";
  }

  char dateStr[11];  // "YYYY-MM-DD"
  sprintf(dateStr, "%04d-%02d-%02d", timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday);
  return String(dateStr);
}

void actualizarIndicadores(int average_bpm, int average_spo2, float temperature) {
  // Actualizar estados compartidos (protegidos por volatilidad)
  
  // BPM: 60 - 100
  if (average_bpm >= 60 && average_bpm <= 100) {
    ledBpmState = 1; // Verde
  } else {
    ledBpmState = 2; // Rojo
  }

  // SpO2: 95 - 100
  if (average_spo2 >= 95 && average_spo2 <= 100) {
    ledSpo2State = 1; // Verde
  } else {
    ledSpo2State = 2; // Rojo
  }

  // Temperatura: 36.1 - 37.2
  if (temperature >= 36.1 && temperature <= 37.2) {
    ledTempState = 1; // Verde
  } else {
    ledTempState = 2; // Rojo
  }
}

void ledControlTask(void *pvParameters) {
  while(1) {
    // Control de LED BPM
    if (ledBpmState == 1) { // Verde
      digitalWrite(BPM_LED_GREEN, LOW);
      digitalWrite(BPM_LED_RED, HIGH);
    } else if (ledBpmState == 2) { // Rojo
      digitalWrite(BPM_LED_GREEN, HIGH);
      digitalWrite(BPM_LED_RED, LOW);
    } else { // Apagado
      digitalWrite(BPM_LED_GREEN, HIGH);
      digitalWrite(BPM_LED_RED, HIGH);
    }

    // Control de LED SpO2
    if (ledSpo2State == 1) { // Verde
      digitalWrite(SPO2_LED_GREEN, LOW);
      digitalWrite(SPO2_LED_RED, HIGH);
    } else if (ledSpo2State == 2) { // Rojo
      digitalWrite(SPO2_LED_GREEN, HIGH);
      digitalWrite(SPO2_LED_RED, LOW);
    } else { // Apagado
      digitalWrite(SPO2_LED_GREEN, HIGH);
      digitalWrite(SPO2_LED_RED, HIGH);
    }

    // Control de LED Temperatura
    if (ledTempState == 1) { // Verde
      digitalWrite(TEMP_LED_GREEN, LOW);
      digitalWrite(TEMP_LED_RED, HIGH);
    } else if (ledTempState == 2) { // Rojo
      digitalWrite(TEMP_LED_GREEN, HIGH);
      digitalWrite(TEMP_LED_RED, LOW);
    } else { // Apagado
      digitalWrite(TEMP_LED_GREEN, HIGH);
      digitalWrite(TEMP_LED_RED, HIGH);
    }

    vTaskDelay(50 / portTICK_PERIOD_MS); // Pequeño delay para evitar sobrecarga
  }
}
he faculty and technical instructors listed in this document convened to formally record that, during this first academic term of 2023, the recommendations made following the 2021 assessment period are being taken into account with respect to Learning Outcome 7:
“Ability to acquire and apply new knowledge as needed, using appropriate learning strategies.”